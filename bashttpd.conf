DIFFICULTY=3

#
# bashttpd.conf - configuration for bashttpd
#
# The behavior of bashttpd is dictated by the evaluation
# of rules specified in this configuration file.  Each rule
# is evaluated until one is matched.  If no rule is matched,
# bashttpd will serve a 500 Internal Server Error.
#
# The format of the rules are:
#    on_uri_match REGEX command [args]
#    unconditionally command [args]
#
# on_uri_match:
#   On an incoming request, the URI is checked against the specified
#   (bash-supported extended) regular expression, and if encounters a match the
#   specified command is executed with the specified arguments.
#
#   For additional flexibility, on_uri_match will also pass the results of the
#   regular expression match, ${BASH_REMATCH[@]} as additional arguments to the
#   command.
#
# unconditionally:
#   Always serve via the specified command.  Useful for catchall rules.
#
# The following commands are available for use:
#
#   serve_file FILE
#     Statically serves a single file.
#
#   serve_dir_with_tree DIRECTORY
#     Statically serves the specified directory using 'tree'.  It must be
#     installed and in the PATH.
#
#   serve_dir_with_ls DIRECTORY
#     Statically serves the specified directory using 'ls -al'.
#
#   serve_dir  DIRECTORY
#     Statically serves a single directory listing.  Will use 'tree' if it is
#     installed and in the PATH, otherwise, 'ls -al'
#
#   serve_dir_or_file_from DIRECTORY
#     Serves either a directory listing (using serve_dir) or a file (using
#     serve_file).  Constructs local path by appending the specified root
#     directory, and the URI portion of the client request.
#
#   serve_static_string STRING
#     Serves the specified static string with Content-Type text/plain.
#
# Examples of rules:
#
# on_uri_match '^/issue$' serve_file "/etc/issue"
#
#   When a client's requested URI matches the string '/issue', serve them the
#   contents of /etc/issue
#
# on_uri_match 'root' serve_dir /
#
#   When a client's requested URI has the word 'root' in it, serve up
#   a directory listing of /
#
# DOCROOT=/var/www/html
# on_uri_match '/(.*)' serve_dir_or_file_from "$DOCROOT"
#   When any URI request is made, attempt to serve a directory listing
#   or file content based on the request URI, by mapping URI's to local
#   paths relative to the specified "$DOCROOT"
#

# More about commands:
#
# It is possible to somewhat easily write your own commands.  An example
# may help.  The following example will serve "Hello, $x!" whenever
# a client sends a request with the URI /say_hello_to/$x:
#
# serve_hello() {
#    add_response_header "Content-Type" "text/plain"
#    send_response_ok_exit <<< "Hello, $2!"
# }
# on_uri_match '^/say_hello_to/(.*)$' serve_hello
#
# Like mentioned before, the contents of ${BASH_REMATCH[@]} are passed
# to your command, so its possible to use regular expression groups
# to pull out info.
#
# With this example, when the requested URI is /say_hello_to/Josh, serve_hello
# is invoked with the arguments '/say_hello_to/Josh' 'Josh',
# (${BASH_REMATCH[0]} is always the full match)

DOCROOT=./data
BLOCKS_DIR=$DOCROOT/blocks
TX_LOG=$DOCROOT/transactions

mine_block() {
  local previous_block_idx=$(ls -t $BLOCKS_DIR | head -1)
  local previous_block_hash=$(sha256sum $BLOCKS_DIR/$previous_block_idx | head -c 64)

  local current_block_idx=$(expr $previous_block_idx + 1)
  local current_timestamp=$(date +%s)

  local proof_of_concept=0
  local current_block=""
  local current_block_hash=""

  try_new_block() {
    current_block=$(echo "{
      \"index\":     $current_block_idx,
      \"timestamp\": $current_timestamp,
      \"proof\":     $proof_of_concept,
      \"transactions\": [],
      \"previousBlockHash\": \"$previous_block_hash\"}" | json_pp -json_opt canonical )

    current_block_hash=$(echo $current_block | sha256sum | head -c 64)
  }

  try_new_block

  local hash_should_match_regex=^0{$DIFFICULTY}.+$
  while ! [[ "${current_block_hash}" =~ ${hash_should_match_regex} ]]; do # TODO: cat /proc/... CPU temp
    proof_of_concept=$(expr $proof_of_concept + 1)
    try_new_block
  done

  if ! [[ -f $BLOCKS_DIR/$current_block_idx ]]; then
    echo $current_block > $BLOCKS_DIR/$current_block_idx

    echo "{\"blocks\":[" > $DOCROOT/blockchain

    for f in $(ls $BLOCKS_DIR) ; do
      cat $BLOCKS_DIR/$f >> $DOCROOT/blockchain
      echo -n ","        >> $DOCROOT/blockchain
    done

    echo "]\",blockHeight\":$current_block_idx}" >> $DOCROOT/blockchain
    echo "{\"clientId\": \"$(cat $DOCROOT/client_id)\", \"currentBlockHeight\": $current_block_idx}" > $DOCROOT/client_info

    add_response_header "Content-Type" "application/json"
    send_response_ok_exit < \
      <(echo "{
        \"message\":   \"Mined a block..\",
        \"blockHash\": \"$current_block_hash\",
        \"block\":     $current_block
      }")
  else
    add_response_header "Content-Type" "text/plain"
    fail_with 409
  fi
}

create_transaction() {
  log "creating transaction"
  local transaction_id=$(uuid)
  local transaction_timestamp=$(date +%s)
  local transaction_payload=$REQUEST_BODY

  local transaction="{
      \"id\":        $transaction_id,
      \"timestamp\": $transaction_timestamp,
      \"payload\":   $transaction_payload,
      \"confirmed\": false
    }"

  LC_ALL=C echo $transaction >> $TX_LOG

  add_response_header "Content-Type" "application/json"
  send_response 201 <<< $transaction
  exit 0
}


on_uri_match "GET" '^/$'            serve_file "$DOCROOT/client_info"
on_uri_match "GET" '^/blocks$'      serve_file "$DOCROOT/blockchain"
on_uri_match "GET" '^/blocks/(.*)$' serve_dir_or_file_from $BLOCKS_DIR
on_uri_match "GET" '^/mine$'        mine_block

on_uri_match "GET"  '^/transactions/?$'    serve_file "$DOCROOT/txlog"
on_uri_match "GET"  '^/transactions/new$'  serve_file "$DOCROOT/new_transaction"
on_uri_match "POST" '^/transactions/?$'    create_transaction

unconditionally serve_static_string 'Please use the correct endpoint.'
